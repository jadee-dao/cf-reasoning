<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Embedding Analysis Viewer</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            background: #f0f2f5;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Stats Header */
        .stats-bar {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            flex: 1;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .stat-label {
            font-size: 0.9em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #2c3e50;
            margin-top: 5px;
        }

        /* Controls */
        .controls {
            margin-bottom: 20px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        select {
            padding: 10px;
            font-size: 16px;
            border-radius: 4px;
            border: 1px solid #ddd;
            width: 100%;
            max-width: 400px;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab-btn {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            background: #ddd;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            transition: background 0.2s;
        }

        .tab-btn.active {
            background: #0066cc;
            color: white;
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
        }

        /* Table */
        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        th,
        td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background-color: #f8f9fa;
            font-weight: bold;
            color: #555;
            text-transform: uppercase;
            font-size: 0.85em;
        }

        tr:hover {
            background-color: #f1f7ff;
            cursor: pointer;
        }

        tr.active-row {
            background-color: #e3effd;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            width: 90%;
            max-width: 1000px;
            max-height: 90vh;
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
            position: relative;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            font-weight: bold;
        }

        /* Utility */
        .rank-badge-sm {
            background: #555;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8em;
        }

        /* Cards */
        .pair-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border-left: 5px solid transparent;
        }

        .pair-card.rank-1 {
            border-left-color: #ffd700;
        }

        /* Gold */
        .pair-card.rank-2 {
            border-left-color: #c0c0c0;
        }

        /* Silver */
        .pair-card.rank-3 {
            border-left-color: #cd7f32;
        }

        /* Bronze */

        .pair-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .rank-badge {
            background: #333;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
            font-weight: bold;
        }

        .score {
            font-size: 1.2em;
            font-weight: bold;
            color: #0066cc;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .item {
            text-align: center;
        }

        .media-container {
            position: relative;
            border-radius: 4px;
            overflow: hidden;
            background: #000;
        }

        video {
            width: 100%;
            display: block;
        }

        img {
            width: 100%;
            display: block;
            border-top: 1px solid #333;
        }

        .label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .debug-label {
            position: absolute;
            top: 0;
            left: 0;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 0.7em;
            padding: 2px 6px;
        }

        .media-container img+.debug-label {
            top: auto;
            bottom: 0;
        }

        /* Label for bottom image */

        .text-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            /* Darker, more solid background */
            color: #ffffff;
            font-size: 14px;
            /* Larger font */
            line-height: 1.4;
            padding: 10px;
            border-bottom: 1px solid #444;
            max-height: 120px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: monospace;
            /* Better for reading structured text */
            z-index: 10;
        }

        .text-overlay:empty {
            display: none;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Embedding Analysis Results</h1>

        <div class="controls">
            <div style="margin-bottom: 10px;">
                <label for="strategySelect"
                    style="font-weight:bold; display:block; margin-bottom:5px;">Strategy:</label>
                <select id="strategySelect" onchange="loadStrategy()">
                    <option value="">Loading...</option>
                </select>
            </div>

            <div>
                <label style="font-weight:bold; display:block; margin-bottom:5px;">Datasets:</label>
                <div id="datasetCheckboxes"
                    style="display:flex; flex-wrap:wrap; gap:15px; background:#f9f9f9; padding:10px; border-radius:4px; border:1px solid #ddd;">
                    <!-- Checkboxes will be injected here -->
                    <span style="color:#666;">Select a strategy first.</span>
                </div>
            </div>
        </div>

        <div id="loading" style="display:none; text-align: center; padding: 20px;">Loading data...</div>

        <div id="dashboard" style="display:none;">
            <!-- Stats Bar -->
            <div class="stats-bar">
                <div class="stat-card">
                    <div class="stat-label">Highest Similarity</div>
                    <div class="stat-value" id="maxScore">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Lowest Similarity</div>
                    <div class="stat-value" id="minScore">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Total Pairs</div>
                    <div class="stat-value" id="totalCount">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Strategy</div>
                    <div class="stat-value" id="strategyName">-</div>
                </div>
            </div>

            <!-- Header Controls -->
            <div
                style="margin-bottom: 20px; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); display:flex; gap:20px; flex-wrap:wrap;">
                <label style="font-weight:bold; cursor:pointer; font-size: 16px;">
                    <input type="checkbox" id="filterSameId" onchange="reloadData()"> Show Different Scenes Only
                    <span style="font-weight:normal; color:#666; margin-left:5px;">(Same UUID sequence)</span>
                </label>
                <label style="font-weight:bold; cursor:pointer; font-size: 16px;">
                    <input type="checkbox" id="filterDiffDataset" onchange="reloadData()"> Show Different Datasets Only
                    <span style="font-weight:normal; color:#666; margin-left:5px;">(Cross-Dataset Only)</span>
                </label>
            </div>

            <!-- Tabs -->
            <div class="tabs">
                <button class="tab-btn active" onclick="switchTab('most')">Top 5 Most Similar</button>
                <button class="tab-btn" onclick="switchTab('least')">Top 5 Least Similar</button>
                <button class="tab-btn" onclick="switchTab('leaderboard')">Leaderboard (All Pairs)</button>
                <button class="tab-btn" onclick="switchTab('scatter')">Embedding Space</button>
            </div>

            <!-- Content -->
            <div id="most" class="section active"></div>
            <div id="least" class="section"></div>
            <div id="scatter" class="section">
                <div style="margin-bottom:15px; display:flex; justify-content:space-between; align-items:center;">
                    <div style="font-size:0.9em; color:#666; max-width:60%;">
                        <strong>About the Plot:</strong>
                        Displaying <span id="pointCount" style="font-weight:bold;">-</span> points from <span
                            id="datasetCount" style="font-weight:bold;">-</span> datasets.
                        <br>
                        <strong>Outliers:</strong> Detected via Isolation Forest on embedding coordinates.
                        <br>
                        <strong>Calibration Set:</strong> Highlighted with orange border (based on 'scene-' ID pattern).
                    </div>
                    <div style="display:flex; align-items:center; gap:20px;">
                        <div style="display:flex; align-items:center; gap:10px;">
                            <label for="outlierSetSelect" style="font-weight:bold;">GT Outlier Set:</label>
                            <select id="outlierSetSelect" style="width:150px; padding:5px; margin:0;"
                                onchange="updateScatter()">
                                <option value="">None</option>
                            </select>
                        </div>
                        <div style="display:flex; align-items:center; gap:10px;">
                            <label for="colorSelect" style="font-weight:bold;">Color By:</label>
                            <select id="colorSelect" style="width:150px; padding:5px; margin:0;"
                                onchange="updateScatter()">
                                <option value="dataset">Dataset Source</option>
                                <option value="uniform">Uniform (Blue)</option>
                                <option value="outlier">Calc. Outliers (Red)</option>
                                <option value="cluster_k3">Clusters (K=3)</option>
                                <option value="cluster_k5">Clusters (K=5)</option>
                                <option value="cluster_k8">Clusters (K=8)</option>
                            </select>
                        </div>
                        <div style="display:flex; align-items:center; gap:10px;">
                            <label for="scopeSelect" style="font-weight:bold;">Scope:</label>
                            <select id="scopeSelect" style="width:150px; padding:5px; margin:0;"
                                onchange="updateScatter()">
                                <option value="independent">Independent</option>
                                <option value="global">Global Combined</option>
                            </select>
                        </div>
                        <div style="display:flex; align-items:center; gap:10px;">
                            <label for="projectionSelect" style="font-weight:bold;">Method:</label>
                            <select id="projectionSelect" style="width:150px; padding:5px; margin:0;"
                                onchange="updateScatter()">
                                <option value="tsne">t-SNE</option>
                                <option value="umap">UMAP</option>
                                <option value="pca">PCA</option>
                            </select>
                        </div>
                    </div>
                </div>
                <!-- Legend -->
                <div
                    style="display:flex; justify-content:flex-end; margin-bottom:10px; gap: 15px; font-size: 0.9em; color:#555;">
                    <div style="display:flex; align-items:center; gap:5px;">
                        <span
                            style="width:12px; height:12px; border-radius:50%; background-color:#0066cc; display:inline-block;"></span>
                        Normal
                    </div>
                    <div style="display:flex; align-items:center; gap:5px;">
                        <span
                            style="width:12px; height:12px; border-radius:50%; background-color:transparent; border: 3px solid #ff8c00; display:inline-block;"></span>
                        Highlight (GT Outlier)
                    </div>
                </div>
                <div id="scatterPlot"
                    style="width:100%; height:600px; background:white; border-radius:8px; box-shadow:0 2px 4px rgba(0,0,0,0.1);">
                </div>
                <div id="scatterDetail" style="margin-top:20px;"></div>
            </div>
            <div id="leaderboard" class="section">
                <!-- ... -->
            </div>
        </div>
    </div>

    <!-- ... (Modals remain same) ... -->

    <script>
        let currentStrategy = '';
        let currentScatterData = null;
        let strategyStructure = {};
        let availableDatasets = [];

        // Initialize
        window.onload = async function () {
            try {
                const response = await fetch('/api/list');
                const data = await response.json();

                strategyStructure = data.structure || {};

                const stratSelect = document.getElementById('strategySelect');
                stratSelect.innerHTML = '';

                if (data.strategies.length > 0) {
                    data.strategies.forEach(s => {
                        const opt = document.createElement('option');
                        opt.value = s;
                        opt.textContent = s;
                        stratSelect.appendChild(opt);
                    });

                    // Explicitly select the first one
                    stratSelect.value = data.strategies[0];

                    // Initialize first strategy
                    initStrategy();
                }
            } catch (e) {
                console.error("Error loading strategies:", e);
            }
        };

        function initStrategy() {
            const strategy = document.getElementById('strategySelect').value;
            if (!strategy) return;

            // Get datasets for this strategy
            availableDatasets = (strategyStructure[strategy] || []).filter(d => d !== 'global');

            renderCheckboxes();
            loadData();
        }

        function renderCheckboxes() {
            const boxesDiv = document.getElementById('datasetCheckboxes');
            boxesDiv.innerHTML = '';

            if (availableDatasets.length === 0) {
                boxesDiv.innerHTML = '<span style="color:#666;">No datasets found.</span>';
                return;
            }

            availableDatasets.forEach(d => {
                const label = document.createElement('label');
                label.style.marginRight = '15px';
                label.style.cursor = 'pointer';
                // Default to checked
                label.innerHTML = `<input type="checkbox" value="${d}" checked onchange="loadData()"> ${d}`;
                boxesDiv.appendChild(label);
            });
        }



        async function loadData() {
            const strategy = document.getElementById('strategySelect').value;
            if (!strategy) return;

            document.getElementById('strategyName').textContent = strategy;

            // Read checkboxes
            let datasetsToLoad = [];
            document.querySelectorAll('#datasetCheckboxes input[type="checkbox"]:checked').forEach(cb => {
                datasetsToLoad.push(cb.value);
            });

            if (datasetsToLoad.length === 0) {
                renderDashboard({ strategy: strategy, datasets: [], points: [], all_pairs: [] });
                return;
            }

            // Show loading
            document.getElementById('loading').style.display = 'block';
            document.getElementById('dashboard').style.opacity = '0.5';

            try {
                const filterSame = document.getElementById('filterSameId').checked;
                const filterDiff = document.getElementById('filterDiffDataset').checked;

                const response = await fetch(`/api/results?strategy=${strategy}&datasets=${datasetsToLoad.join(',')}&filter_same_id=${filterSame}&filter_diff_dataset=${filterDiff}`);
                const data = await response.json();

                data.strategy = strategy;
                renderDashboard(data);

                document.getElementById('loading').style.display = 'none';
                document.getElementById('dashboard').style.display = 'block';
                document.getElementById('dashboard').style.opacity = '1.0';

            } catch (e) {
                console.error("Error loading results:", e);
                document.getElementById('loading').innerHTML = `<div style="color:red;">Error loading results: ${e}</div>`;
            }
        }

        // Alias for old call
        async function loadStrategy() {
            initStrategy();
        }

        async function reloadData() {
            loadData();
        }

        function switchTab(tabId) {
            // Update buttons
            const tabs = document.querySelectorAll('.tab-btn');
            tabs.forEach(t => {
                t.classList.remove('active');
                if (t.getAttribute('onclick').includes(`'${tabId}'`)) {
                    t.classList.add('active');
                }
            });

            // Update sections
            const sections = document.querySelectorAll('.section');
            sections.forEach(s => s.classList.remove('active'));

            const target = document.getElementById(tabId);
            if (target) {
                target.classList.add('active');
            }

            // Resize plot if needed
            if (tabId === 'scatter') {
                setTimeout(() => {
                    if (window.Plotly) {
                        Plotly.Plots.resize(document.getElementById('scatterPlot'));
                    }
                }, 50);
            }
        }

        function renderDashboard(data) {
            // Update Stats
            document.getElementById('maxScore').textContent = data.global_max_score !== undefined ? data.global_max_score.toFixed(4) : '-';
            document.getElementById('minScore').textContent = data.global_min_score !== undefined ? data.global_min_score.toFixed(4) : '-';
            document.getElementById('totalCount').textContent = data.total_pairs !== undefined ? data.total_pairs : 0;
            document.getElementById('strategyName').textContent = data.strategy;

            // NO LONGER RENDER CHECKBOXES HERE (we do it in initStrategy)

            // Render Scatter
            if (data.points) {
                currentScatterData = data.points;
                currentStrategy = data.strategy;
                document.getElementById('pointCount').textContent = data.points.length;

                // If scope is global, we might want to say "All" instead of listing datasets?
                // Or just show loaded count
                document.getElementById('datasetCount').textContent = data.datasets ? data.datasets.length : 0;

                // Populate GT Outlier Select
                const gtSelect = document.getElementById('outlierSetSelect');
                const currentVal = gtSelect.value; // Try to preserve selection
                gtSelect.innerHTML = '<option value="">None</option>';

                const allKeys = new Set();
                data.points.forEach(p => {
                    if (p.gt_outliers) {
                        Object.keys(p.gt_outliers).forEach(k => allKeys.add(k));
                    }
                });

                allKeys.forEach(k => {
                    const opt = document.createElement('option');
                    opt.value = k;
                    opt.textContent = k;
                    gtSelect.appendChild(opt);
                });

                if (currentVal && allKeys.has(currentVal)) {
                    gtSelect.value = currentVal;
                } else if (allKeys.has('ade_p90')) {
                    gtSelect.value = 'ade_p90';
                }

                // Populate Scope Select
                const scopeSelect = document.getElementById('scopeSelect');
                const currentScope = scopeSelect.value;
                scopeSelect.innerHTML = '';

                // Option 1: Global Combined
                const globalOpt = document.createElement('option');
                globalOpt.value = 'global';
                globalOpt.textContent = 'Global Combined';
                scopeSelect.appendChild(globalOpt);

                // Option 2+: Individual Datasets
                if (data.datasets && data.datasets.length > 0) {
                    data.datasets.forEach(d => {
                        if (d === 'global') return; // Skip if 'global' is somehow in list
                        const opt = document.createElement('option');
                        opt.value = d;
                        opt.textContent = `${d} (Independent)`;
                        scopeSelect.appendChild(opt);
                    });
                }

                // Restore selection if valid, or default to global? 
                // Or force global if currentScope is 'independent' which no longer exists?
                if (currentScope && (currentScope === 'global' || (data.datasets && data.datasets.includes(currentScope)))) {
                    scopeSelect.value = currentScope;
                } else {
                    scopeSelect.value = 'global';
                }

                updateScatter();
            } else {
                document.getElementById('scatterPlot').innerHTML = ''; // Clear
            }

            // Render Lists
            if (data.all_pairs) {
                renderList('most', data.all_pairs.slice(0, 5), currentStrategy);
                const least = data.least_similar || (data.all_pairs.length > 5 ? data.all_pairs.slice(-5).reverse() : []);
                renderList('least', least, currentStrategy);
                renderList('leaderboard', data.all_pairs.slice(0, 200), currentStrategy);
            } else {
                ['most', 'least', 'leaderboard'].forEach(id => document.getElementById(id).innerHTML = '');
            }
        }

        function renderList(containerId, pairs, strategy) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            if (!pairs || pairs.length === 0) {
                container.innerHTML = '<div style="color:#666; text-align:center; padding:20px;">No pairs found.</div>';
                return;
            }

            pairs.forEach((item, index) => {
                const id1 = item.pair[0];
                const id2 = item.pair[1];
                const score = item.score.toFixed(4);

                let rankClass = '';
                if (index === 0) rankClass = 'rank-1';
                if (index === 1) rankClass = 'rank-2';
                if (index === 2) rankClass = 'rank-3';

                const div = document.createElement('div');
                div.className = `pair-card ${rankClass}`;
                div.innerHTML = `
                    <div class="pair-header">
                        <div>
                            <span class="rank-badge">#${index + 1}</span>
                            <span style="font-weight:bold; margin-left:10px;">Similarity:</span>
                            <span class="score">${score}</span>
                            <span style="margin-left:10px; font-size:0.9em; color:#666;">(${item.dataset})</span>
                        </div>
                    </div>
                    <div class="comparison">
                        <div class="item">
                            ${renderItem(id1, strategy, item.dataset, true)}
                        </div>
                        <div class="item">
                             ${renderItem(id2, strategy, item.dataset, true)}
                        </div>
                    </div>
                 `;
                container.appendChild(div);

                // Trigger debug load (lazy or immediate?)
                // Immediate for top 5 lists
                loadDebugText(id1, strategy, item.dataset);
                loadDebugText(id2, strategy, item.dataset);
            });
        }

        function renderItem(id, strategy, dataset, showDebug = false) {
            let debugHtml = '';
            // Only show debug if explicitly requested and dataset is known
            if (showDebug && dataset) {
                const debugImgUrl = `/debug/${strategy}/${dataset}/${id}`;
                debugHtml = `
                    <div style="margin-top:10px; text-align:left;">
                        <div class="label" style="font-size:0.8em; margin-bottom:2px;">Debug View</div>
                        <img src="${debugImgUrl}" 
                             onerror="this.style.display='none'" 
                             style="width:100%; border:1px solid #eee; border-radius:4px; display:block; margin-bottom:5px;">
                        
                        <div id="debug-text-${id}" 
                             style="font-family:monospace; font-size:0.85em; background:#f8f9fa; color:#333; padding:8px; border-radius:4px; border:1px solid #eee; white-space:pre-wrap; display:none; max-height:300px; overflow-y:auto;"></div>
                    </div>
                `;
            }

            return `
                <div class="media-container">
                    <video controls loop muted playsinline preload="metadata">
                        <source src="/video/${id}" type="video/mp4">
                        Video not found
                    </video>
                </div>
                <div style="margin-top:5px; font-family:monospace; font-size:0.9em;">
                    ${id}
                </div>
                ${debugHtml}
            `;
        }


        function updateScatter() {
            if (!currentScatterData) return;

            const method = document.getElementById('projectionSelect').value;
            const colorSelect = document.getElementById('colorBySelect') || document.getElementById('colorSelect');
            const colorBy = colorSelect ? colorSelect.value : 'dataset';
            const gtSet = document.getElementById('outlierSetSelect').value;
            const scopeSelect = document.getElementById('scopeSelect');
            const scope = scopeSelect ? scopeSelect.value : 'global';

            // Filter points based on scope
            let points = [];
            if (scope === 'global') {
                points = currentScatterData; // Show all
            } else {
                // Specific dataset selected
                points = currentScatterData.filter(p => p.dataset === scope);
            }

            // Determine Colors
            let colors = [];
            let opacity = 0.8;

            // Collect datasets for discrete color mapping
            const datasetSet = new Set();
            points.forEach(p => datasetSet.add(p.dataset));
            const distinctDatasets = Array.from(datasetSet).sort();
            const datasetColorMap = {};
            const palette = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
            distinctDatasets.forEach((d, i) => {
                datasetColorMap[d] = palette[i % palette.length];
            });

            colors = points.map(p => {
                let projSource = p.projections_independent;
                if (scope === 'global' && p.projections_global) {
                    projSource = p.projections_global;
                }
                if (!projSource) projSource = p.projections || {};

                const proj = projSource[method] || {};

                if (colorBy === 'outlier') {
                    return proj.is_outlier ? '#ff0000' : '#0066cc';
                } else if (colorBy.startsWith('cluster_')) {
                    const k = proj[colorBy] !== undefined ? proj[colorBy] : 0;
                    return palette[k % palette.length];
                } else if (colorBy === 'dataset') {
                    return datasetColorMap[p.dataset] || '#0066cc';
                } else {
                    return '#0066cc';
                }
            });

            // Determine sizes / lines based on GT Outlier
            const pointSizes = [];
            const lineColors = [];
            const lineWidths = [];

            points.forEach(p => {
                let isGt = false;
                if (gtSet && p.gt_outliers && p.gt_outliers[gtSet]) {
                    isGt = true;
                }
                pointSizes.push(12);
                lineColors.push(isGt ? '#ff8c00' : 'rgba(0,0,0,0)');
                lineWidths.push(isGt ? 3 : 0);
            });

            // Build Traces
            const x = [];
            const y = [];
            const text = []; // Need to rebuild text since we filtered
            const ids = [];

            points.forEach(p => {
                let projSource = p.projections_independent;
                if (scope === 'global' && p.projections_global) {
                    projSource = p.projections_global;
                }
                if (!projSource) {
                    if (p.projections) projSource = p.projections;
                }

                const proj = projSource ? projSource[method] : null;

                if (proj) {
                    x.push(proj.x);
                    y.push(proj.y);
                    text.push(`${p.id}<br>Dataset: ${p.dataset || 'N/A'}`);
                    ids.push(p.id);
                } else {
                    x.push(0);
                    y.push(0);
                    text.push(`${p.id} (No Proj)`);
                    ids.push(p.id);
                }
            });

            const trace = {
                x: x,
                y: y,
                mode: 'markers',
                type: 'scatter',
                text: text,
                marker: {
                    size: pointSizes,
                    color: colors,
                    opacity: opacity,
                    line: {
                        color: lineColors,
                        width: lineWidths
                    }
                },
                hoverinfo: 'text',
                hoverlabel: {
                    bgcolor: colors,
                    bordercolor: lineColors
                }
            };

            const titleScope = scope === 'global' ? 'Global Combined' : `${scope} (Independent)`;

            const layout = {
                title: `${method.toUpperCase()} Space: ${titleScope}`,
                hovermode: 'closest',
                dragmode: 'pan',
                xaxis: { title: 'Dimension 1', zeroline: false },
                yaxis: { title: 'Dimension 2', zeroline: false },
                margin: { t: 40 }
            };

            Plotly.newPlot('scatterPlot', [trace], layout, { responsive: true });

            document.getElementById('scatterPlot').on('plotly_click', function (data) {
                const pt = data.points[0];
                const index = pt.pointIndex;
                const pointData = points[index]; // Use local filtered points list!
                const id = pointData.id;

                // Show detail
                const detailDiv = document.getElementById('scatterDetail');
                detailDiv.innerHTML = `
                    <h3>Selected: ${id} <span style="font-size:0.6em; color:#666;">(${pointData.dataset})</span></h3>
                    <div style="background:white; padding:20px; border-radius:8px; box-shadow:0 2px 4px rgba(0,0,0,0.1);">
                        ${renderItem(id, currentStrategy, pointData.dataset, true)}
                    </div>
                `;
                // Scroll to detail
                detailDiv.scrollIntoView({ behavior: 'smooth' });

                // Load debug text
                loadDebugText(id, currentStrategy, pointData.dataset);
            });
        }

        async function loadDebugText(id, strategy, dataset) {
            const container = document.getElementById(`debug-text-${id}`);
            if (!container) return;

            try {
                const response = await fetch(`/debug_text/${strategy}/${dataset}/${id}`);
                if (response.ok) {
                    const text = await response.text();
                    if (text && text.trim().length > 0) {
                        container.textContent = text;
                        container.style.display = 'block';
                    }
                }
            } catch (e) {
                console.error("Error loading debug text", e);
            }
        }
    </script>
</body>

</html>